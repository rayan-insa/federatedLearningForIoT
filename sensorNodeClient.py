import random
import datetime
import socket
import pandas as pd


def preprocess_data(data):
    # Extract features and labels
    X = [[d[3], d[4].timestamp(), d[5]] for d in data]  # temperature, timestamp, condition
    y = [d[6] for d in data]  # isHeatIsland

    # Encode categorical data
    le = LabelEncoder()
    X = [[x[0], x[1], le.fit_transform([x[2]])[0]] for x in X]

    return X, y

def trainModel(data, model):
    X, y = preprocess_data(data)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Convert to tensors
    X_train = torch.tensor(X_train, dtype=torch.float32)
    y_train = torch.tensor(y_train, dtype=torch.float32).view(-1, 1)
    X_test = torch.tensor(X_test, dtype=torch.float32)
    y_test = torch.tensor(y_test, dtype=torch.float32).view(-1, 1)

    criterion = nn.BCEWithLogitsLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    # Training loop
    epochs = 100
    for epoch in range(epochs):
        model.train()
        optimizer.zero_grad()
        outputs = model(X_train)
        loss = criterion(outputs, y_train)
        loss.backward()
        optimizer.step()

        if (epoch+1) % 10 == 0:
            print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}')

    # Evaluate the model
    model.eval()
    with torch.no_grad():
        outputs = model(X_test)
        predicted = (torch.sigmoid(outputs) > 0.5).float()
        accuracy = (predicted == y_test).sum().item() / y_test.size(0)
        print(f'Accuracy: {accuracy:.4f}')

    return model


class SensorNode():

    def __init__(self, stationId, sendingNumber=10):
        self.sendingNumber = sendingNumber
        self.stationId = stationId
        dataWithoutY = self.generateSensorsData()
        print("All the data is generated by sensor node", self.stationId)

        self.data = self.addYtoData(dataWithoutY=dataWithoutY)
        print("The model is ready to be trained", self.stationId)

        # Appel de function d'entrainement du model avc entrainement

        """with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((DEST_IP, DEST_PORT))
            s.send(str(data).encode(ENCODER))

            if i == self.sendingNumber-1:
                s.send('QUIT'.encode(ENCODER))"""
            
        # Enregistrement dans un fichier pth des wieghts


    def generateSensorsData(self):
        # Generate random data
        dataWithoutY = []

        for i in range(self.sendingNumber):
            longitude = stationDic[self.stationId][0]
            latitude = stationDic[self.stationId][1]
            day = random.randint(1, 30)
            month = random.randint(1, 12)
            year = random.randint(2019, 2024)
            timestamp = datetime.datetime(year, month, day)
            if self.stationId <= (len(stationsCoords)-1)/2 :
                if month <= 2 and month >= 11:
                    temperature = random.randint(5, 15)
                else :
                    temperature = random.randint(18, 35)
            else :
                if month <= 2 and month >= 11:
                    temperature = random.randint(-3, 13)
                else :
                    temperature = random.randint(15, 30)
            condition = random.choice(conditions)

            dataWithoutY.append([self.stationId, latitude, longitude, temperature, timestamp, condition])
        
        return dataWithoutY

    def addYtoData(self, dataWithoutY):
        # Read the Istanbul_Weather_Data.csv file and fetch MaxTemp, MinTemp, Condition, and DateTime
        # Do the avg of max and min temp for each data line.
        # Take all the lines of the file and compare for each dataWithoutY the condition and month.
        # For all lines with same condition and month as dataWithoutY, take the avg of all the avgs max and min temp into temperature.
        # Compare the temparatures and if they have a difference of 3 or 4, add a column to dataWithoutY with the value 1, else 0.
        
        weather_data = pd.read_csv('Istanbul_Weather_Data.csv')
        months=[]
        for date in weather_data['DateTime']:
            month = date.split('.')[1]
            months.append(month)
        weather_data['DateTime'] = months
        weather_data['AvgTemp'] = (weather_data['MaxTemp'] + weather_data['MinTemp']) / 2
        for data in dataWithoutY:
            station_id, latitude, longitude, temperature, timestamp, condition = data
            relevant_data = weather_data[(weather_data['Condition'] == condition) & (weather_data['DateTime'] == timestamp.month)]
            avg_temp = relevant_data['AvgTemp'].mean()

            if temperature - avg_temp >= 4:
                data.append(1)
            else:
                data.append(0)

        return dataWithoutY

        

if __name__ == "__main__":

    stationsCoords = [(41.133, 29.067), (41.25, 29.033), (40.9, 29.15), (40.977, 28.821), (40.97, 28.82), (40.9, 29.31), (40.899, 29.309), (40.667, 29.283)]
    stationDic = {i : station for i, station in enumerate(stationsCoords)}
    conditions = ["Sunny", "Partly cloudy", "Light rain shower", "Moderate snow"]
    sendingNumber = 10 # Number of data to send

    stationId = int(input(f"Enter the stationID you are (0-{len(stationsCoords)-1}): "))
    SensorNode(stationId, sendingNumber)